//c:\program files\postgresql\9.3\bin> pg_dump.exe -U postgres personDB >"d:\backup.sql" <-- to export db
//c:\program files\postgresql\9.3\bin> psql -h localhost -p 5432  -U postgres newDBname < D:\backup.sql <-- to import db
//C:\Program Files\PostgreSQL\9.0\bin\pg_dump.exe --host localhost --port 5432 --username postgres --format plain --ignore-version --verbose --file "C:\temp\filename.backup" --table public.tablename dbname <-- to export special table
package main

import (
	"encoding/csv"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"strconv"
	"time"

	"github.com/jinzhu/gorm"
	_ "github.com/jinzhu/gorm/dialects/postgres"
	"github.com/jung-kurt/gofpdf"
	echo "github.com/labstack/echo"
	"github.com/labstack/echo/middleware"
	_ "github.com/lib/pq"
)

// UserNotificationLog - log of user notificaton
type UserNotificationLog struct {
	gorm.Model
	RedirectURL string `json:"redirect_url"`
	Text        string `json:"text"`
	To          uint   `json:"to"`
	Status      string `json:"status"`
	Type        string `json:"type"`
}

// NotificationUserPreference - It stores the user preference
type NotificationUserPreference struct {
	gorm.Model
	UserID      uint `json:"user_id" gorm:"unique_index:ucid"`
	ConditionID uint `json:"condition_id" gorm:"unique_index:ucid"`
	IsEmail     bool `json:"is_email"`
	IsWeb       bool `json:"is_web"`
	IsMobile    bool `json:"is_mobile"`
	Value       bool `json:"value"`
	Frequency   int  `json:"frequency"`
}

// NotificationToken - store token generated by firebase
type NotificationToken struct {
	UserID       uint   `json:"user_id"`
	WebToken     string `json:"web_token"`
	AndroidToken string `json:"android_token"`
	IosToken     string `json:"ios_token"`
}

// MstNotification - master table for mapping condition
type MstNotification struct {
	gorm.Model
	Name        string `json:"name"`
	Question    string `json:"question"`
	RedirectURL string `json:"redirect_url"`
	Type        string `json:"type"`
}

// NotificationRole - Mapping of condition and Professional Name
type NotificationRole struct {
	gorm.Model
	ProfessionName string            `json:"professional_name"`
	Condition      []MstNotification `gorm:"foreignkey:ConditionID;association_foreignkey:ID"`
	ConditionID    uint              `json:"condition_id"`
}

//Person struct
type Person struct {
	// gorm.Model
	ID        int     `gorm:"primary_key:true;id"`
	Firstname string  `json:"first_name"`
	Lastname  string  `json:"last_name"`
	Age       int     `json:"age"`
	Gender    string  `json:"gender"`
	Salary    int     `jaon:"salary"`
	Address   Address `gorm:"foreignkey:ID;association_foreignkey:ID"`
	Contact   Contact `gorm:"foreignkey:ID;association_foreignkey:ID"`
}

//Address struct
type Address struct {
	// gorm.Model
	ID    uint   `json:"id"`
	City  string `json:"city"`
	State string `json:"state"`
	Pin   string `json:"pin"`
}

//Contact struct
type Contact struct {
	// gorm.Model
	ID     uint   `json:"id"`
	Mobile string `gorm:"not null;unique;mobile"`
	Email  string `gorm:"not null;unique;email"`
}

//function for request handaling
func handlerequest() {
	//echo new objct created
	e := echo.New()
	e.Use(middleware.CORS())
	e.Use(middleware.Logger())
	e.Use(middleware.Recover())

	//Router to the diffrent functions
	e.POST("/person", PostPerson)
	e.POST("/SetUserPreference", SetUserPreference)

	e.POST("/getfilteredperon", GetPersonsByPostData)

	e.GET("/", helloWorld)
	e.GET("/salrytotal", GetSalarySum)
	e.GET("/agesalarysum", GetSumOfAgeSalary)

	e.GET("/person", GetAll)
	e.GET("/person/:ID", GetPerson)
	e.GET("/person/a/:ID", GetAddress)
	e.GET("/person/f/:ID", GetFullname)
	e.GET("/person/c/:ID", GetContact)

	e.PUT("/person/:ID", UpdatePerson)

	e.DELETE("/person/:ID", DeletePerson)
	e.Logger.Fatal(e.Start(":12345"))

}

//finction for error checking
func checkError(err error) {
	if err != nil {
		log.Panic("Error detected-->", err)
	}
}

//DBConnection
func DBConnection() (*gorm.DB, error) {
	db, err := gorm.Open("postgres",
		`host=localhost 
							port=5432 
							user=postgres 
							dbname=personDB 
							password=root 
			sslmode=disable`)
	return db, err
}

//initiatMigrate function for migratation od tables
func initiatMigrate() {
	db, err := DBConnection()
	checkError(err)
	defer db.Close()

	db.AutoMigrate(
		&Person{},
		&Address{},
		&Contact{},
		&MstNotification{},
		&NotificationRole{},
		&NotificationToken{},
		&NotificationUserPreference{},
	)
}

//Persons new veriable os type person
var Persons []Person
var people Person

// var addresses Address
var adresses []Address
var contacts []Contact

//helloWorld
func helloWorld(c echo.Context) (err error) {
	return c.String(http.StatusOK, "Hello, World!")
}

//SetUserPreference sets user preference as notification on mobile or web or email
func SetUserPreference(c echo.Context) (err error) {
	db, err := DBConnection()
	checkError(err)
	defer db.Close()

	nup := new(NotificationUserPreference)

	if err := c.Bind(nup); err != nil {
		return err
	}
	fmt.Println("nub", nup)
	if err := db.Where(map[string]interface{}{
		"user_id":      nup.UserID,
		"condition_id": nup.ConditionID,
	}).Find(&nup).Error; err != nil {
		fmt.Println("error", err)
		if err := db.Where(
			map[string]interface{}{
				"user_id":      nup.UserID,
				"condition_id": nup.ConditionID,
			},
		).Assign(*nup).FirstOrCreate(nup).Error; err != nil {
			return err
		}
		return c.JSON(http.StatusOK, &nup)

	}
	return c.JSON(http.StatusOK, &nup)
}

//PostPerson
func PostPerson(c echo.Context) (err error) {
	db, err := DBConnection()
	checkError(err)
	defer db.Close()

	u := new(Person)

	if err := c.Bind(u); err != nil {
		return err
	}
	if err := db.Create(&u).Error; err != nil {
		return err
	}
	return c.JSON(http.StatusOK, &u)
}

//GetAll records from database and return as a JSON data in http response
func GetAll(c echo.Context) error {
	db, err := DBConnection()
	checkError(err)
	defer db.Close()

	type People struct {
		People json.RawMessage `json:"people"`
	}
	var ap People
	Query := `select * from get_all_person()`
	if err := db.Raw(Query).Scan(&ap).Error; err != nil {
		fmt.Println("error", err)
	}
	return c.JSON(http.StatusOK, &ap)
}

//GetPerson by id from database and return as a JSON data in http response
func GetPerson(c echo.Context) error {
	db, err := DBConnection()
	checkError(err)
	defer db.Close()

	type Person struct {
		Person json.RawMessage `json:"person"`
	}
	var p Person
	id := c.Param("ID")
	Query := `select * from get_person(?)`
	if err := db.Raw(Query, id).Scan(&p).Error; err != nil {
		fmt.Println("error", err)
	}
	return c.JSON(http.StatusOK, &p)
}

//DeletePerson by id from database
func DeletePerson(c echo.Context) error {
	db, err := DBConnection()
	checkError(err)
	defer db.Close()

	e := new(Person)
	a := new(Address)
	var g []Contact
	id := c.Param("ID")
	db.Where("id=?", id).Find(&e).Delete(&e)
	db.Where("id=?", id).Find(&a).Delete(&a)
	db.Where("id=?", id).Find(&g).Delete(&g)
	return c.JSON(http.StatusOK, 204)
}

//GetPersonsByPostData order by ? from database and return as a JSON data in http response
func GetPersonsByPostData(c echo.Context) error {
	db, err := DBConnection()
	checkError(err)
	defer db.Close()

	type RequestBody struct {
		Offset     uint
		Limit      uint
		ColumnName string
		TableName  string
		OrderBy    string
	}
	rb := new(RequestBody)
	if err := c.Bind(rb); err != nil {
		fmt.Println(err)
		return err
	}
	var all []Person
	query := "SELECT * FROM " + rb.TableName
	orderby := " ORDER BY " + rb.ColumnName + " " + rb.OrderBy
	limit := " LIMIT ?"
	offset := " OFFSET ?"
	query = query + orderby + " " + limit + offset

	fmt.Println("â€‹query", query)

	if err := db.Raw(query, rb.Limit, rb.Offset).Preload("Address").Preload("Contact").Find(&all).Error; err != nil {
		fmt.Println("Error-->", err)
	}
	return c.JSON(http.StatusOK, &all)
}

//GetSalarySum of salary coulmn
func GetSalarySum(c echo.Context) error {
	db, err := DBConnection()
	checkError(err)
	defer db.Close()
	var all []Person
	var sum int
	query := "SELECT salary FROM people"
	if err := db.Raw(query).Find(&all).Error; err != nil {
		fmt.Println("error->", err)
	}
	for i := 0; i < len(all); i++ {
		sum += all[i].Salary
	}
	fmt.Println("sum->", sum)
	return c.JSON(http.StatusOK, sum)
}

//GetSumOfAgeSalary of salary coulmn
func GetSumOfAgeSalary(c echo.Context) error {
	db, err := DBConnection()
	checkError(err)
	defer db.Close()

	type Total struct {
		Total int `json:"total"`
	}

	var s Total
	query := "SELECT SUM(coalesce(salary,0)+coalesce(age,0)) as total From people"
	if err := db.Raw(query).Scan(&s).Error; err != nil {
		fmt.Println("error", err)
	}
	fmt.Println("TOTAl-->", s)
	return c.JSON(http.StatusOK, s)
}

//UpdatePerson by id in database and return as a JSON data in http response
func UpdatePerson(c echo.Context) error {
	db, err := DBConnection()
	checkError(err)
	defer db.Close()

	type UpdatedAddress struct {
		City  string `json:"city"`
		State string `json:"state"`
		Pin   string `json:"pin"`
	}
	type UpdatedContact struct {
		ID     uint   `json:"id"`
		Mobile string `json:"mobile"`
		Email  string `json:"email"`
	}
	type NewPerson struct {
		ID        int            `gorm:"primary_key:true"`
		Firstname string         `json:"firstname"`
		Lastname  string         `json:"lastname"`
		Gender    string         `json:"gender"`
		Salary    int            `json:"salary"`
		Age       int            `json:"age"`
		Address   UpdatedAddress `json:"address"`
		Contact   UpdatedContact `json:"contact"`
	}
	n := new(NewPerson)
	if err := c.Bind(n); err != nil {
		fmt.Println(err)
		return err
	}

	p := new(Person)
	id, err := strconv.Atoi(c.Param("ID"))
	checkError(err)
	p.ID = id

	p.Firstname = n.Firstname
	p.Lastname = n.Lastname
	p.Age = n.Age
	p.Gender = n.Gender
	p.Salary = n.Salary
	p.Address.State = n.Address.State
	p.Address.City = n.Address.City
	p.Address.Pin = n.Address.Pin
	p.Contact.Mobile = n.Contact.Mobile
	p.Contact.Email = n.Contact.Email

	db.Where("id = ?", id).Save(p)

	db.Find(&p)
	return c.JSON(http.StatusOK, &p)
}

//GetAddress by id from database and return as a JSON data in http response
func GetAddress(c echo.Context) error {
	db, err := DBConnection()
	checkError(err)
	defer db.Close()
	type Address struct {
		Address json.RawMessage `json:"Address"`
	}
	var a Address
	id := c.Param("ID")

	Query := `select * from get_person_address(?)`
	if err := db.Raw(Query, id).Scan(&a).Error; err != nil {
		fmt.Println("error", err)
	}
	return c.JSON(http.StatusOK, a)
}

//GetFullname by id from database and return as a JSON data in http response
func GetFullname(c echo.Context) error {
	db, err := DBConnection()
	checkError(err)
	defer db.Close()

	type Fullname struct {
		Fullname json.RawMessage `json:"fullname"`
	}
	var f Fullname
	id := c.Param("ID")
	Query := `select * from get_person_fullname(?)`
	if err := db.Raw(Query, id).Scan(&f).Error; err != nil {
		fmt.Println("error", err)
	}
	fmt.Println("TOTAl-->", f)
	return c.JSON(http.StatusOK, &f)
}

//GetContact by id from database and return as a JSON data in http response
func GetContact(c echo.Context) error {
	db, err := DBConnection()
	checkError(err)
	defer db.Close()

	type Contact struct {
		Contact json.RawMessage `json:"contact"`
	}
	var con Contact
	id := c.Param("ID")
	Query := `select * from get_person_contact(?)`
	if err := db.Raw(Query, id).Scan(&con).Error; err != nil {
		fmt.Println("error", err)
	}
	return c.JSON(http.StatusOK, con)
}

//main function
func main() {
	fmt.Println("Project started successfully")
	initiatMigrate()
	handlerequest()
	data := loadCSV(path())
	pdf := newReport()
	pdf = header(pdf, data[0])
	pdf = table(pdf, data[1:])
	pdf = image(pdf)
	if pdf.Err() {
		log.Fatalf("Failed creating PDF report: %s\n", pdf.Error())
	}
	err := savePDF(pdf)
	if err != nil {
		log.Fatalf("Cannot save PDF: %s|n", err)
	}
}

func newReport() *gofpdf.Fpdf {
	pdf := gofpdf.New("L", "mm", "Letter", "")
	pdf.AddPage()
	pdf.SetFont("Times", "B", 28)
	pdf.Cell(40, 10, "Daily Report")
	pdf.Ln(12)

	pdf.SetFont("Times", "", 20)
	pdf.Cell(40, 10, time.Now().Format("Mon Jan 2, 2006"))
	pdf.Ln(20)

	return pdf
}

func header(pdf *gofpdf.Fpdf, hdr []string) *gofpdf.Fpdf {
	pdf.SetFont("Times", "B", 16)
	pdf.SetFillColor(240, 240, 240)
	for _, str := range hdr {
		pdf.CellFormat(40, 7, str, "1", 0, "", true, 0, "")
	}

	pdf.Ln(-1)
	return pdf
}

func table(pdf *gofpdf.Fpdf, tbl [][]string) *gofpdf.Fpdf {

	pdf.SetFont("Times", "", 16)
	pdf.SetFillColor(255, 255, 255)
	align := []string{"L", "C", "L", "R", "R", "R"}
	for _, line := range tbl {
		for i, str := range line {
			pdf.CellFormat(40, 7, str, "1", 0, align[i], false, 0, "")
		}
		pdf.Ln(-1)
	}
	return pdf
}

func image(pdf *gofpdf.Fpdf) *gofpdf.Fpdf {
	pdf.ImageOptions("/stats.jpg", 225, 10, 25, 25, false, gofpdf.ImageOptions{ImageType: "PNG", ReadDpi: true}, 0, "")
	return pdf
}

func savePDF(pdf *gofpdf.Fpdf) error {
	return pdf.OutputFileAndClose("report.pdf")
}

func loadCSV(path string) [][]string {
	f, err := os.Open(path)
	if err != nil {
		log.Fatalf("Cannot open '%s': %s\n", "./testgo.csv", err.Error())
	}
	defer f.Close()
	r := csv.NewReader(f)
	rows, err := r.ReadAll()
	if err != nil {
		log.Fatalln("Cannot read CSV data:", err.Error())
	}
	return rows
}

func path() string {
	if len(os.Args) < 2 {
		return "testgo.csv"
	}
	return os.Args[1]
}
